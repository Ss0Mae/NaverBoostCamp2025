# **윷놀이 말판 Ⓜ️**

## **학습 키워드**

**배열**

**사전**

**알고리즘**

## **추가 정보**

**난이도**

**상**

---

**중요도**

**보통**

---

**권장 학습 시간**

**1H**

---

**미션 해결 예상 시간**

**3H**

# **학습 목표**

- 필요한 데이터 구조(배열, 사전, 맵 등)를 적극 활용할 수 있다.
- 저장된 데이터 구조에서 요구사항에 맞춰서 탐색할 수 있다.
- 함수를 하위 함수로 분리할 수 있다.

# **사전지식**

- 없음

# **기능요구사항**

윷놀이 말판을 기준으로 다음과 같은 규칙을 만족하는 보드 게임을 개발하려고 합니다. Z에서 출발해서 다시 Z까지 빠르게 돌아오는 보드 게임입니다.

![yut-board](https://lucas-image.codesquad.kr/1700731429322yut-board.png)

### **보드게임 규칙**

- 모든 말은 Z 위치에서 시작한다고 가정합니다.
- 입력값에 따라 보드에서 숫자가 커지는 방향으로 전진하고, 작아지는 방향으로 전진할 수는 없습니다.
- 정확하게 분기점이 있는 위치 W(위치값 ZW5), V(위치값 WV3), X(위치값 WX5)에 도착했을 때는 항상 짧은 방향을 선택합니다.
    - W와 X에서는 V방향, V에서는 Z방향을 선택합니다.
    - V에서 X를 선택하거나 Y에서 V로 선택하지 않습니다.
- 입력값이 정확하게 분기점에 도착하지 않고 지나치는 경우에는 꺾인 방향으로 들어갈 수 없습니다.
    - ZW4에서 K가 나오면 WV1 위치가 아니라 WX1 위치로 이동합니다.
- 윷이나 모가 나왔을 때 연속으로 던지는 경우는 고려하지 않습니다.
- 이미 다른 참가자 말이 있더라도 윷놀이처럼 잡지 않고 같은 위치에 있을 수 있습니다.
- 윷놀이와 다르게 여러 말이 합쳐져서 움직이지 않습니다. 하나의 말이 Z에 도착할 때까지 다른 말을 내려놓지 않아야 합니다.
- 점수로 득점하는 경우는 도착할 때 Z에 도착하거나 Z를 지나친 경우입니다.
- 2명 이상 여러 참가자가 있다고 가정하고 입력값을 배열 형식으로 제공합니다.
- 만약 입력에서 던진 횟수가 서로 다른 경우는 오류로 판단하고 "ERROR" 에러값을 포함하는 배열을 리턴합니다

# **프로그래밍 요구사항**

이번 미션은

- 하드 코딩하거나 비교문을 최소화하고
- 각 언어의 콜랙션 타입(배열, 집합, 사전, 맵)을 적극 활용해서
- score() 함수를 구현합니다.
- score() 함수에서 호출하는 하위 함수를 구조적으로 분리해 보세요.

## **동작 설명**

입력값은 참가자별로 한 글자 이상의 문자열을 포함하는 배열로 개수 2개 이상의 값을 포함합니다.

- 입력 예시 **`["D", "K"]`** , **`["U", "G", "D", "D"]`**

입력값은 각 참가자가 던진 윷을 문자로 합쳐서 전달합니다.

- D: 1칸 전진
- K: 2칸 전진
- G: 3칸 전진
- U: 4칸 전진
- M: 5칸 전진

결과값으로 만드는 보드에서 위치는 Z, W, V, X, Y와 숫자를 **`“출발노드 + 도착노드 + 숫자”`** 형식의 3자리 문자열을 만들어야 합니다. 예를 들어 입력값이 "DG" 라면 ZW4 위치가 되고, "MG" 이라면 WV3 위치입니다.

출력값은 다음과 같은 형식으로 각 참가자 점수와 말판에서 남은 말의 위치값을 콤마로 구분해서 순서대로 출력합니다.

예를 들어 첫번째 참가자는 말이 WV3에 있고 0점이며, 두번째 참가자는 WX1에 있고 1점이면 **`["0, WV3", "1, WX1"]`** 으로 출력합니다.

### **제약사항**

- 입력값에서 참가자 배열은 최소 2개에서 최대 10개까지 가능합니다. 만약 범위를 벗어난 경우는 "ERROR" 값만 포함하는 배열을 리턴합니다.
- 입력값의 문자열 크기는 참가자마다 최대 50자까지 주어집니다. 예외 처리는 구현하지 않아도 됩니다.
- 마지막 위치값이 도착지점 "Z"인 경우는 방향 상관없이 항상 "Z"만 출력합니다.
- 입력값 문자 중에 **`DKGUM`**가 아닌 경우는 최종 점수는 표시하고 위치값 대신 "ERR"를 출력합니다.
- 만약 입력 배열에서 던진 횟수가 서로 다른 경우는 오류로 판단하고 "ERROR" 에러값만 포함하는 배열을 리턴합니다.

### **구현 이후 규칙 파괴하기 (선택사항)**

- 반드시 기능 구현을 완료한 다음에, (현실 윷놀이에 가깝도록) 위에 규칙 중에서 하나를 골라서 파괴하고 확장해서 구현해보세요
    - 어떤 규칙을 선택했나요?
    - 왜 선택했나요?
    - 어떻게 바꾸는 게 좋을까요?
    - 이것을 고려해서 미리 설계한 부분이 있나요?

# **예상결과 및 동작예시**

### **예시 1**

- 입력값: **`["DG"]`** 또는 **`["DG", "D"]`**
- 출력값: **`["ERROR"]`**

### **예시 2**

- 입력값: **`["DGD", "MGG"]`**
- 출력값: **`["0, ZW5", "1, Z"]`**

### **예시 3**

- 입력값: **`["DGGG", "MGGA"]`**
- 출력값: **`["0, WX5", "1, ERR"]`**

### **예시 3**

- 입력값: **`["DGDGGK", "DDDDDK", "KKKKKD"]`**
- 출력값: **`["1, ZW2", "0, WV2, "0, XV1"]`**

---

# 개발 회고 보고서

## 1. 초기 접근 및 설계

이번 미션의 핵심은 윷놀이 말판의 복잡한 이동 규칙을 코드로 구현하는 것이었습니다. 특히 분기점에서 '정확히 도착'하는 경우와 '지나치는' 경우를 구분하는 것이 가장 큰 도전 과제였습니다.

이를 해결하기 위해 다음과 같은 데이터 구조를 선택했습니다.

- **`DISTANCES` (Object)**: 각 노드 간의 거리를 `{"Z-W": 5, ...}` 형태로 저장했습니다. 경로의 길이를 쉽게 조회할 수 있어 선택했습니다.
- **`STRAIGHT_PATH` (Object)**: 각 노드에서 직진했을 때의 다음 노드를 `{"Z": "W", ...}` 형태로 저장했습니다. 분기점을 지나치는 경우의 경로 선택을 위함입니다.
- **`SHORTCUT_PATH` (Object)**: 분기점에서 지름길로 갔을 때의 다음 노드를 `{"W": "V", ...}` 형태로 저장했습니다. 분기점에 정확히 도착했을 때의 경로 선택을 위함입니다.

이처럼 규칙의 종류에 따라 데이터 구조를 분리함으로써, `if`문을 최소화하고 코드의 가독성과 유지보수성을 높이고자 했습니다.

## 2. 구현 과정 및 핵심 로직

가장 핵심적인 부분은 말을 이동시키는 `advance` 함수였습니다. 처음에는 반복문을 사용하여 구현하려 했으나, 한 번의 이동(예: `DGDGGK`)으로 여러 경로를 연속적으로 지나가는 복잡한 경우를 처리하기 어려웠습니다.

이 문제를 해결하기 위해 **재귀 호출** 방식을 도입했습니다.

```javascript
function advance(state, step) {
  // ... 현재 경로에서 이동 ...

  if (used >= dist) { // 현재 경로를 완주하고도 이동할 칸이 남았다면
    // ... 다음 경로 정보 계산 ...
    return advance(newState, overflow); // 남은 칸(overflow)만큼 다음 경로에서 재귀 호출
  }

  return state; // 경로 중간에 멈춤
}
```

이 재귀 구조 덕분에, 아무리 긴 이동이라도 각 경로를 순차적으로 방문하며 규칙(분기점, Z 도착)을 올바르게 적용할 수 있었습니다.

## 3. 실수 및 문제 해결 과정

개발 과정에서 몇 가지 중요한 실수를 경험했습니다.

### 1. 출력 형식 불일치 문제

- **문제**: 초기 구현에서는 말의 최종 위치를 기준으로 "현재 노드"와 "다음 노드"를 표시했습니다 (예: `WV3`). 하지만 Readme의 예시는 "이전 노드"와 "현재 노드"를 기준으로 표시하고 있었습니다 (예: `ZW5`).
- **해결**: 이 문제를 해결하기 위해 `advance` 함수에 `prevEdge`라는 상태를 추가했습니다. 이 상태는 말이 마지막으로 완주한 경로의 정보를 저장합니다. 최종 위치를 출력할 때 이 `prevEdge` 정보를 사용하여 Readme의 예시와 동일한 형식(`이전노드-도착노드-거리`)으로 출력할 수 있었습니다.

### 2. `ReferenceError: dist is not defined`

- **문제**: `movePiece` 함수에서 `state` 객체를 구조 분해 할당할 때 `dist` 변수를 누락하여 참조 오류가 발생했습니다.
- **해결**: `const { from, to, used, score } = state;`를 `const { from, to, dist, used, score } = state;`로 수정하여 간단히 해결했습니다. 사소하지만 중요한 실수였습니다.

## 4. 결론

이번 미션은 단순히 기능을 구현하는 것을 넘어, 복잡한 규칙을 어떻게 데이터와 로직으로 분리하여 효과적으로 표현할 수 있는지 깊이 고민하는 계기가 되었습니다. 특히 재귀 함수와 상태 객체(`state`)를 활용하여 복잡한 이동 로직을 명확하고 간결하게 구현할 수 있었던 점이 가장 큰 수확이었습니다.

## 5. 규칙 파괴하기 (선택사항)

### 어떤 규칙을 선택했나요?
"윷이나 모가 나왔을 때 연속으로 던지는 경우는 고려하지 않습니다" 와 "입력 배열에서 던진 횟수가 서로 다른 경우는 오류로 판단합니다" 라는 두 가지 규칙을 파괴하고 확장하기로 선택했습니다.

### 왜 선택했나요?
실제 윷놀이의 가장 큰 재미 요소는 '윷'이나 '모'를 던져 한 번 더 플레이할 기회를 얻는 것입니다. 이 규칙을 적용하면 게임이 훨씬 더 현실감 있고 박진감 넘치게 변합니다. 또한, 추가 턴을 얻는다는 것은 자연스럽게 참가자별로 총 던진 횟수가 달라지는 것을 의미하므로, 두 번째 규칙(던진 횟수 동일)도 함께 변경해야 했습니다.

### 어떻게 바꾸는 게 좋을까요?
가장 간단하고 효과적인 방법은 `score` 함수에서 모든 참가자의 던진 횟수(입력 문자열의 길이)가 동일한지 검사하는 로직을 제거하는 것입니다.

```javascript
// 제거된 코드
// const L = allTurns[0].length;
// if (!allTurns.every((s) => s.length === L)) {
//   return ["ERROR"];
// }
```

이렇게 하면, 외부에서 입력값을 전달할 때 윷('U')이나 모('M')를 던진 참가자에게 추가 이동 문자(예: `["D", "UG"]`)를 포함하여 전달하는 것만으로 새로운 규칙을 간단히 적용할 수 있습니다.

### 이것을 고려해서 미리 설계한 부분이 있나요?
네, 있습니다. 초기 설계부터 각 참가자의 이동을 처리하는 `movePiece(turn)` 함수는 다른 참가자의 상태와 완전히 독립적으로 동작하도록 구현했습니다. 각 참가자의 결과는 `allTurns.map(...)`을 통해 개별적으로 계산됩니다.

이러한 **모듈화된 설계** 덕분에, 참가자 간의 상호작용(여기서는 '던진 횟수 비교')에 해당하는 로직만 제거하면 다른 핵심 로직(말 이동, 점수 계산 등)을 전혀 수정하지 않고도 새로운 규칙을 손쉽게 확장하고 적용할 수 있었습니다.