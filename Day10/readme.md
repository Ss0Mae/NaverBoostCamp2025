# **기능요구사항**

다음 제공하는 모델 zip 파일을 다운로드하고, 압축을 풀면 나오는 모델 파일을 분석해서 결과를 출력해야 합니다. 압축 해제 자체는 구현할 필요 없습니다.

[models.zip](https://lucas-image.codesquad.kr/1747822362626models.zip)

압축 해제 후 model 파일은 다음과 같이 구성되어 있습니다.

```
data.model
objects/a.model
objects/b.model
objects/c.model

```

### **data.model**

종합 모델 데이터로 A, B, C 오브젝트에 대해 파일 경로를 가지고 있습니다. 반드시 이 경로에 맞춰서 파일을 읽어야 합니다.

### **data 구조 예시**

```
#objects
path="/Objects/a.model" objectid="1"
path="/Objects/b.model" objectid="5"
path="/Objects/c.model" objectid="9"

```

### **a.model , b.model , c.model**

- objects 디렉토리 아래에 각각 A, B, C 오브젝트에 대한 모델 파일입니다.
- vertex 데이터와 triangle 데이터를 포함하고 있습니다.
- vertex 한 줄 데이터는 3차원 좌표로 x, y, z 값을 가집니다.
    - 좌표값은 실수 범위를 가지며 구분을 위해서 따옴표로 묶여 있습니다.
    - 각 x, y, z 좌표값은 공백으로 구분합니다.
- vertex 데이터를 읽어서 배열로 저장하세요.
- triangle 한 줄 데이터는 3차원 평면상의 삼각형으로 v1, v2, v3 - 3개의 vertex 좌표를 참조합니다.
    - 참조하는 값은 vertex 데이터 배열의 인덱스 값입니다. 인덱스는 0부터 시작합니다.
    - 아래 예시에서 **`v1="0"`** 은 0번째 vertex **`x="1" y="10" z="5"`** 를 의미합니다.
- model 파일의 한 줄은 **`\n`** 줄바꿈 문자를 포함합니다. vertex 와 triangle 영역 구분은 줄바꿈 문자가 연속으로 나타납니다.

### **vertex 와 triangle 구조 예시**

```
#vertices
x="1" y="10" z="5"
x="-10" y="1" z="5"
x="10" y="10.5" z="5"
x="15" y="15" z="5.12345"
x="20" y="20" z="5"

#triangles
v1="0" v2="1" v3="2"
v1="1" v2="3" v3="4"
v1="3" v2="4" v3="0"

```

# **프로그래밍 요구사항**

### **5초 분석 과정 표시**

실행 후 파일을 분석한 다음 (분석 전 또는 후) 콘솔 화면에 **`5초 동안 분석이 진행됨을`** 업데이트하는 Progress Bar를 직접 구현해서 표시해야 합니다. 적어도 10% 마다 업데이트해서 100%까지 진행 상황을 보여줘야 합니다. 분석 과정을 10단계로 나눠야 하는 것은 아니고 5초 동안 진행을 표시만 하면 됩니다.

```
예시1
▓▓▓▓▓▓▓▓▓▓░░░░░░░░░░ 50%
예시2
██████████▁▁▁▁▁▁▁▁▁▁ 50%
예시3
⚫⚫⚫⚫⚫⚪⚪⚪⚪⚪ 50%

```

- 터미널 설정을 ANSI로 해놓고 ANSICode 코드를 출력하면 폰트색이나 배경색을 지정할 수도 있습니다.
    - ANSI 샘플 코드 https://gist.github.com/godrm/95c9ac19cacd8b8d29127ce908182ae3

### **분석 결과 표시**

5초 Progress Bar 표시 이후에 다음과 같은 분석 결과를 출력합니다.

1. Object를 구성하는 Triangle 중에서 X 축으로 가장 긴 값을 포함하는 것의 objectid (X 축 길이가 가장 긴 삼각형은?)
2. Object를 구성하는 Triangle 중에서 Y 축으로 가장 긴 값을 포함하는 것의 objectid (Y 축 길이가 가장 긴 삼각형은?)
3. Object를 구성하는 Triangle 중에서 Z 축으로 가장 긴 값을 포함하는 것의 objectid (Z 축 길이가 가장 긴 삼각형은?)
4. Object를 구성하는 Triangle 중에서 가장 면적이 넓은 것의 objectid

---

## 고민과정

1.  **요구사항 분석:**
    *   `data.model` 파일을 읽어 각 object 모델 파일의 경로와 ID를 파악해야 한다.
    *   각 object 모델 파일 (`.model`)에서 vertex와 triangle 데이터를 파싱해야 한다.
    *   Vertex 데이터는 3D 좌표(x, y, z)를 가지고, triangle 데이터는 vertex 배열의 인덱스 3개를 참조한다.
    *   분석 과정 중 5초 동안 진행률을 표시하는 Progress Bar를 구현해야 한다.
    *   분석이 끝나면 다음 4가지 결과를 출력해야 한다:
        1.  X축 길이가 가장 긴 triangle을 포함하는 object ID.
        2.  Y축 길이가 가장 긴 triangle을 포함하는 object ID.
        3.  Z축 길이가 가장 긴 triangle을 포함하는 object ID.
        4.  면적이 가장 넓은 triangle을 포함하는 object ID.

2.  **필요한 데이터셋:**
    *   `data.model`: object 파일들의 메타데이터.
    *   `objects/A.model`, `objects/B.model`, `objects/C.model`: 실제 3D 모델 데이터.

3.  **생각과정 (구현 순서):**
    1.  **파일 파싱:**
        *   `data.model`을 파싱하여 각 모델의 경로와 ID를 객체 배열로 만든다.
        *   각 모델 파일(`.model`)을 파싱하는 함수를 만든다. 이 함수는 vertex와 triangle 데이터를 분리하고, 각각을 파싱하여 구조화된 데이터(객체 배열)로 변환한다.
            *   Vertex 파싱: 정규식을 사용하여 각 줄에서 x, y, z 값을 추출하고 숫자로 변환한다.
            *   Triangle 파싱: 정규식을 사용하여 각 줄에서 v1, v2, v3 값을 추출하고 정수로 변환한다.
    2.  **계산 로직:**
        *   Triangle의 세 꼭짓점(vertex) 좌표를 이용해 X, Y, Z 축 길이를 계산하는 함수를 만든다.
            *   `X 길이 = max(v1.x, v2.x, v3.x) - min(v1.x, v2.x, v3.x)`
        *   Triangle의 면적을 계산하는 함수를 만든다. 헤론의 공식을 사용하면 3D 공간에서도 세 변의 길이만 알면 면적을 구할 수 있다.
            1.  세 변의 길이(a, b, c)를 구한다 (3D 공간 두 점 사이의 거리 공식).
            2.  `s = (a + b + c) / 2`
            3.  `면적 = sqrt(s * (s - a) * (s - b) * (s - c))`
    3.  **메인 로직:**
        *   `data.model`에서 얻은 모델 정보를 순회한다.
        *   각 모델에 대해 파일 파싱을 수행한다.
        *   파싱된 triangle 데이터를 순회하며 각 triangle의 X, Y, Z 길이와 면적을 계산한다.
        *   최대값을 저장할 변수 4개(maxX, maxY, maxZ, maxArea)를 만들고, 각 변수에 `{ value: 값, objectId: ID }` 형태로 저장한다.
        *   순회하면서 현재 triangle의 계산값이 기존 최대값보다 크면 변수를 업데이트한다.
    4.  **Progress Bar 구현:**
        *   `setInterval`과 `process.stdout.write('\r')`를 사용하여 한 줄에서 진행률이 업데이트되는 효과를 만든다.
        *   5초 동안 10%씩 (0.5초마다) 업데이트되도록 설정한다.
        *   `async/await`와 `Promise`를 사용하여 5초가 지난 후에 다음 분석 로직이 실행되도록 보장한다.
    5.  **결과 출력:**
        *   모든 계산이 끝난 후, 저장된 최대값 변수들에서 object ID를 가져와 형식에 맞게 출력한다.

4.  **구현과정:**
    *   Node.js 환경에서 `fs` 모듈을 사용하여 파일을 동기적으로 읽었다. 파일 I/O가 많지 않고 순차적으로 처리해야 하므로 동기 방식이 더 간단하다고 판단했다.
    *   `path` 모듈을 사용하여 플랫폼에 독립적인 파일 경로를 만들었다.
    *   정규식을 사용하여 각 데이터 라인에서 필요한 값을 정확하게 추출했다.
    *   계산 로직과 파싱 로직을 별도의 함수로 분리하여 코드의 가독성과 재사용성을 높였다.
    *   Progress Bar는 `async/await`를 사용하여 비동기적으로 구현했지만, 메인 분석 로직의 실행을 막는 형태로 구현하여 순차적인 실행 흐름을 유지했다.

5.  **구현과정에서의 실수 (또는 고려사항):**
    *   **경로 문제:** `data.model`에 있는 경로가 `/Objects/a.model`과 같이 슬래시로 시작하여 처음에는 절대 경로로 착각할 수 있었다. 하지만 `__dirname`을 기준으로 상대 경로를 조합해야 올바르게 파일을 찾을 수 있었다. `path.join`을 사용하여 이 문제를 해결했다.
    *   **데이터 파싱 오류:** 모델 파일의 마지막 줄에 개행 문자가 있거나 없을 수 있어, `split('\n')` 후 `filter(line => line)`과 같은 처리를 추가하여 빈 줄로 인한 오류를 방지했다.
    *   **3D 공간에서의 면적 계산:** 처음에는 2D 삼각형 면적 공식을 생각했지만, vertex가 3D 좌표이므로 3D 공간에서의 면적을 구해야 했다. 헤론의 공식은 3D에서도 변의 길이만 알면 적용 가능하므로 이를 사용했다. 각 변의 길이는 3D 공간의 두 점 사이의 거리 공식을 사용하여 계산했다.
    *   **Progress Bar와 비동기 처리:** `setInterval`은 비동기적으로 작동하므로, Progress Bar가 표시되는 동안 다음 코드가 실행될 수 있다. 이를 막고 5초간의 분석 시간을 보장하기 위해 `new Promise(resolve => setTimeout(resolve, 5000))`와 `await`를 함께 사용하여 5초가 끝날 때까지 메인 스레드의 진행을 의도적으로 지연시켰다.

