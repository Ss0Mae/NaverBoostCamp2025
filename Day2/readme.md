## **학습 키워드**

**2차원배열**

**데이터구조**

**해시맵**

## **추가 정보**

**난이도**

**중**

---

**중요도**

**보통**

---

**권장 학습 시간**

**1H**

---

**미션 해결 예상 시간**

**3H**

# **학습 목표**

- 주어진 조건을 분석하고 어떤 데이터 구조를 왜 사용해야 하는지 스스로 판단할 수 있다.
- 주어진 조건에 맞는 데이터 구조를 배열로 표현하고 탐색하면서 채울 수 있다.

# **사전지식**

- 없음

# **기능요구사항**

다음과 같은 규칙을 가지는 숫자 카드 게임을 구현하려고 합니다.

- 숫자가 1부터 100까지 적힌 카드가 있다고 가정합니다.
- 4개 숫자 배열을 만들고, 각 배열에는 10, 30, 50, 80을 배치합니다.
- 참가자는 3명으로 고정합니다.
- A, B, C 참가자 3명은 10, 30, 50, 80을 제외하고 랜덤하게 10장씩 나눠 갖고 게임을 시작합니다. 랜덤 카드 분배를 구현하지 않아도 됩니다.
- 각 턴마다 3명이 동시에 한 장씩 카드를 내려놓습니다.
- 가장 작은 숫자를 내려놓은 사람 카드부터 배열 마지막에 있는 카드와 비교해서 추가할 수 있습니다.
    - **A 조건)** 내려놓는 카드와 배열 마지막 카드 차이가 가장 가까운 숫자 뒤에만 내려놓을 수 있습니다. 단 차이가 동일할 경우는 배열의 마지막 카드 숫자가 더 큰 것을 선택합니다.
    - 예를 들어 20은 50이나 80 보다 30이 가까우니 [30] 배열에 추가할 수 있습니다.
    - 65의 경우는 50과 80 중간이라서 [80] 배열에 추가할 수 있습니다.
    - **B 조건)** 배열 마지막 숫자보다 내려놓을 카드가 반드시 더 작아야 해당 배열 뒤에 카드를 추가할 수 있습니다. (= 배열 마지막 숫자가 내려놓을 숫자보다 큰 경우만 추가할 수 있다.)
    - 예를 들어 내려놓은 카드가 9라면 10과 1 차이가 나고 작은 숫자니까 내려놓을 수 있습니다.
    - A) B) 두 가지 조건 모두 만족해야 배열에 추가해서 내려놓을 수 있습니다.
- 특정 참가자 카드가 A) B) 두 조건에 맞춰서 배열에 추가할 수 없다면, A) 조건에 의해 선택된 배열을 비우고, 비운 배열의 카드 개수만큼 벌점을 받습니다.

```
배열1 = [10]
배열2 = [30]
배열3 = [50]
배열4 = [80]

상태에서 A = 21, B = 9, C = 4 카드를 냈다면
카드가 작은 순서인 4 -> 9 -> 21 순으로 진행합니다.

C 카드는 4는 배열 1 = [10, 4] 형태로 배열 1에 추가합니다.
B 카드는 9라서 4와 차이가 가장 적습니다. 그럼에도 4보다 커서 내려놓을 수가 없어서,
B는 배열 1에 있는 카드 개수만큼 벌점 2점을 추가하고 배열 1 은 []로 비워집니다.
A 카드 21은 30에 가까우니 배열 2 = [30, 21]로 배열2에 추가하고 턴이 끝납니다.

```

- 빈 배열에는 더 이상 추가하지 못합니다.
- 여러 턴을 진행할 수 있지만, 시작할 때 4개 배열이 다 비워진 경우는 게임을 종료합니다.

### **구현 요구사항**

위 게임 요구사항을 만족하는 **`play()`** 함수를 작성하세요.

- A, B, C 3명의 참가자가 있다고 가정하고 매 턴마다의 카드 숫자 값을 입력으로 제공합니다.
- 숫자값을 보고 적당한 배열 뒤에 추가하거나, 배열을 비워야 합니다.
- 더 이상 입력값이 없거나, 더 이상 비울 배열이 없으면 게임을 종료합니다.
- 종료 시점에는 각 참가자별 벌점을 리턴하세요.
- 만약 입력 배열 개수가 3의 배수가 아니라면 리턴값을 모두 0점으로 처리합니다.

# **프로그래밍 요구사항**

### **play() 함수**

- 매개변수 **`param0`**는 참가자 A, B, C 순서로 매 턴마다 내려놓은 카드 3개씩 포함하는 1차원 배열입니다.
    - 예시) **`[1,2,3]`** 는 A 카드 1, B 카드 2, C 카드 3을 내려놓았다는 의미입니다.
    - 예시) **`[51,12,11,15,9,61]`** 는 1번째 턴에서 A 카드 51, B 카드 12, C 카드 11을 내려놓았다는 의미입니다. 2번째 턴에서는 A가 15, B가 9, C가 61을 내려놓았습니다.
- 리턴값은 맵(또는 사전) 형태로 참가자별 벌점을 포함합니다.
    - 예시) **`[ "A" : 2, "B" : 0, "C" : 3]`**

# **예상결과 및 동작예시**

### **예시1)**

입력 **`[21,9,4]`** 인 경우

- 카드가 작은 순서인 4 -> 9 -> 21 순으로 진행합니다.
- C 카드는 4는 배열1 = [10, 4] 형태로 배열 1에 추가합니다.
- B 카드는 9라서 4와 차이가 가장 적습니다. 그럼에도 4보다 크기 때문에 내려놓을 수가 없어서 B는 배열 1에 있는 카드 개수만큼 벌점 2점을 추가하고 배열 1 은 **`[]`**로 비워집니다.
- A 카드 21은 30에 가까우니 배열 2 = [30, 21]로 배열 2에 추가하고 턴이 끝납니다.

### **리턴값**

JS: **`Map([["A", '0'], ["B", '2'], ["C", '0']])`**

---

### **예시2)**

입력 **`[55,8,29,13,7,61]`** 인 경우

- 3개씩 끊어서 카드가 작은 순서로 첫 번째 턴은 8 -> 29 -> 55 순으로, 두 번째 턴은 7 -> 13 -> 61 순으로 진행합니다.
- 첫 번째 턴
    - B 카드 8은 10과 가까우면서 작으니까 배열 1 = [10, 8]
    - C 카드 29는 30과 가까우면서 작으니까 배열 2 = [30, 29]
    - A 카드 55는 50과 가깝지만 더 큰 값이니 추가하지 못하고 배열 3을 비우면서 벌점 1점
- 두 번째 턴
    - B 카드 7은 7과 가깝고 작으니까 배열 1 = [10, 8, 7]
    - A 카드 13은 7과 가깝지만 더 큰 값이니 추가하지 못하고 배열 1을 비우면서 벌점 3점
    - C 카드 61은 80과 가깝고 작으니까 배열4 = [80, 61] 추가하고 끝납니다.

### **리턴값**

JS: **`Map([["A", '4'], ["B", '0'], ["C", '0']])`**

---

# 요구사항 이해하기

1. 숫자 카드 1–100 중 일부(10, 30, 50, 80)를 **4개의 라인**(`lines`)으로 관리
2. A, B, C 참가자 3명 고정 → 각 턴에 [A, B, C] 순으로 한 장씩 제출 (`cards[]`)
3. **턴당 처리 순서**: 세 장을 오름차순 정렬 후 작은 카드부터 실행
4. 각 카드 `x` 처리:
    - **조건 A**: `lines[i]` 마지막 요소와 `|last - x|`가 최소인 라인을 고름
        - 동률 시, 더 큰 `last` 가진 라인 우선
    - **조건 B**: `lines[i].at(-1) > x` 여야 추가 가능
    - A·B 모두 만족 → `lines[i].push(x)`
    - 실패 → `penalty[player] += lines[i].length; lines[i] = []`
5. **빈 라인**(`[]`)에는 더 이상 어떤 카드도 추가 불가
6. **종료 조건**: 입력 카드 소진 또는 모든 라인이 빈 상태 → 점수 리턴
7. **예외 처리**: `cards.length % 3 !== 0` → 즉시 `{A:0,B:0,C:0}` 리턴

---

# **생각의 과정**

1. 규칙 분석: 사다리 게임의 기본 흐름을 이해하고, 배열 4개와 점수판을 어떻게 표현할지 고민했습니다.
2. 자료구조 결정: 각 라인을 2차원 배열(`lines`)로, 벌점을 객체(`penalty`)로 관리하면 직관적이라고 판단했습니다.
3. 핵심 로직 설계: 3명의 카드 처리 순서와 배열 선택 기준(조건 A,B)을 의사코드로 먼저 작성했습니다.
4. 경계/예외 고민: 입력 길이가 3의 배수가 아닐 때, 모든 배열이 비워진 상황 등을 사전에 처리하기로 했습니다.
5. 검증 전략: 단위 테스트(예시1, 예시2)로 결과를 먼저 예상하고, 구현 후 로그로 확인하도록 계획했습니다

---

# 로직 설계하기

- 배열(`lines`)을 2차원 배열로 선언하고, 인덱스 0–3에 `[10]`, `[30]`, `[50]`, `[80]` 초기화
- 점수(`penalty`)는 객체 `{ A: 0, B: 0, C: 0 }`로 관리
- 한 턴의 입력:[xA, xB, xC] → `for (i=0; i<cards.length; i+=3)`
- **순서 결정**: `round.map((v,idx)=>([v,playerMap[idx]])).sort((a,b)=>a[0]-b[0])`

---

# **구현 과정**

1. **입력 검증**
    
    ```jsx
    if (cards.length % 3 !== 0) {
      return new Map([['A',0],['B',0],['C',0]]);
    }
    ```
    
2. **상태 초기화**
    
    ```jsx
    const lines = [[10],[30],[50],[80]];
    const penalty = { A:0, B:0, C:0 };
    const players = ['A','B','C'];
    ```
    
3. **턴 반복**
    
    ```jsx
    for (let i = 0; i < cards.length; i += 3) {
      const round = cards.slice(i, i+3);
      // [ [value, player], ... ]
      const sorted = round
        .map((v,j) => [v, players[j]])
        .sort((a,b) => a[0] - b[0]);
    
      for (const [x, p] of sorted) {
        // 4개 라인 중 최적 라인 탐색
        let target = 0, minDiff = Infinity;
        for (let idx = 0; idx < 4; idx++) {
          const line = lines[idx];
          if (line.length === 0) continue;
          const last = line[line.length - 1];
          const diff = Math.abs(last - x);
          if (
            diff < minDiff ||
            (diff === minDiff && last > lines[target].at(-1))
          ) {
            minDiff = diff;
            target = idx;
          }
        }
        // 조건 B 체크
        const lastVal = lines[target].at(-1);
        if (lastVal > x) {
          lines[target].push(x);
        } else {
          penalty[p] += lines[target].length;
          lines[target] = [];
        }
      }
    }
    ```
    
4. **결과 반환**
    
    ```jsx
    return new Map(Object.entries(penalty));
    ```
    

---

# **완성 코드**

```jsx
function play(cards) {
  if (cards.length % 3 !== 0) {
    return new Map([['A',0],['B',0],['C',0]]);
  }

  const lines = [[10],[30],[50],[80]];
  const penalty = { A:0, B:0, C:0 };
  const players = ['A','B','C'];

  for (let i = 0; i < cards.length; i += 3) {
    const round = cards.slice(i, i+3);
    const sorted = round
      .map((v,j) => [v, players[j]])
      .sort((a,b) => a[0] - b[0]);

    for (const [x,p] of sorted) {
      let target=0, minDiff=Infinity;
      for (let idx=0; idx<4; idx++) {
        const line = lines[idx];
        if (line.length===0) continue;
        const last = line.at(-1);
        const diff = Math.abs(last - x);
        if (diff < minDiff || (diff===minDiff && last>lines[target].at(-1))) {
          minDiff = diff;
          target = idx;
        }
      }
      const lastVal = lines[target].at(-1);
      if (lastVal > x) {
        lines[target].push(x);
      } else {
        penalty[p] += lines[target].length;
        lines[target] = [];
      }
    }
  }

  return new Map(Object.entries(penalty));
}
```

---

# **결과 로그 예시**

```jsx
// 예시1: [21,9,4]
console.log(play([21,9,4])); // Map { 'A' => 0, 'B' => 2, 'C' => 0 }

// 예시2: [55,8,29,13,7,61]
console.log(play([55,8,29,13,7,61])); // Map { 'A' => 4, 'B' => 0, 'C' => 0 }
```

---